<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>jdbc.core documentation</title></head><body><header><section class="title"><h1><a href="index.html">Clojure.jdbc Api Documentation</a></h1></section><small>Version: 0.6.1</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></div></li><li class="depth-2 branch"><a href="jdbc.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-2 branch current"><a href="jdbc.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jdbc.meta.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meta</span></div></a></li><li class="depth-2 branch"><a href="jdbc.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2"><a href="jdbc.resultset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>resultset</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">jdbc.core</h2><div class="doc"><div class="markdown"><p>Alternative implementation of jdbc wrapper for clojure.</p></div></div><div class="public anchor" id="var-atomic"><h3><a href="#var-atomic">atomic</a></h3><h4 class="type">macro</h4><div class="usage"><code>(atomic conn &amp; body)</code></div><div class="doc"><div class="markdown"><p>Creates a context that evaluates in transaction (or nested transaction). This is a more idiomatic way to execute some database operations in atomic way.</p>
<pre><code>(jdbc/atomic conn
  (jdbc/execute conn &quot;DROP TABLE foo;&quot;)
  (jdbc/execute conn &quot;DROP TABLE bar;&quot;))
</code></pre><p>Also, you can pass additional options to transaction:</p>
<pre><code>(jdbc/atomic conn {:read-only true}
  (jdbc/execute conn &quot;DROP TABLE foo;&quot;)
  (jdbc/execute conn &quot;DROP TABLE bar;&quot;))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L214">view source</a></div></div><div class="public anchor" id="var-atomic-apply"><h3><a href="#var-atomic-apply">atomic-apply</a></h3><div class="usage"><code>(atomic-apply conn func &amp; [{:keys [savepoints strategy], :or {savepoints true}, :as opts}])</code></div><div class="doc"><div class="markdown"><p>Wrap function in one transaction. This function accepts as a parameter a transaction strategy. If no one is specified, <code>DefaultTransactionStrategy</code> is used.</p><p>With <code>DefaultTransactionStrategy</code>, if current connection is already in transaction, it uses truly nested transactions for properly handle it. The availability of this feature depends on database support for it.</p>
<pre><code>(with-open [conn (jdbc/connection)]
  (atomic-apply conn (fn [conn] (execute! conn &#39;DROP TABLE foo;&#39;))))
</code></pre><p>For more idiomatic code, you should use <code>atomic</code> macro.</p><p>Depending on transaction strategy you are using, this function can accept additional parameters. The default transaction strategy exposes two additional parameters:</p>
<ul>
  <li><code>:isolation-level</code> - set isolation level for this transaction</li>
  <li><code>:read-only</code> - set current transaction to read only</li>
</ul></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L176">view source</a></div></div><div class="public anchor" id="var-connection"><h3><a href="#var-connection">connection</a></h3><div class="usage"><code>(connection dbspec)</code><code>(connection dbspec options)</code></div><div class="doc"><div class="markdown"><p>Creates a connection to a database. As parameter accepts:</p>
<ul>
  <li>dbspec map containing connection parameters</li>
  <li>dbspec map containing a datasource (deprecated)</li>
  <li>URI or string (interpreted as uri)</li>
  <li>DataSource instance</li>
</ul><p>The dbspec map has this possible variants:</p><p>Classic approach:</p>
<ul>
  <li><code>:subprotocol</code> -&gt; (required) string that represents a vendor name (ex: postgresql)</li>
  <li><code>:subname</code> -&gt; (required) string that represents a database name (ex: test)  (many others options that are pased directly as driver parameters)</li>
</ul><p>Pretty format:</p>
<ul>
  <li><code>:vendor</code> -&gt; (required) string that represents a vendor name (ex: postgresql)</li>
  <li><code>:name</code> -&gt; (required) string that represents a database name (ex: test)</li>
  <li><code>:host</code> -&gt; (optional) string that represents a database hostname (default: 127.0.0.1)</li>
  <li><code>:port</code> -&gt; (optional) long number that represents a database port (default: driver default)  (many others options that are pased directly as driver parameters)</li>
</ul><p>URI or String format: <code>vendor://user:password@host:post/dbname?param1=value</code></p><p>Additional options:</p>
<ul>
  <li><code>:schema</code> -&gt; string that represents a schema name (default: nil)</li>
  <li><code>:read-only</code> -&gt; boolean for mark entire connection read only.</li>
  <li><code>:isolation-level</code> -&gt; keyword that represents a isolation level (<code>:none</code>, <code>:read-committed</code>,  <code>:read-uncommitted</code>, <code>:repeatable-read</code>, <code>:serializable</code>)</li>
</ul><p>Opions can be passed as part of dbspec map, or as optional second argument. For more details, see documentation.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L37">view source</a></div></div><div class="public anchor" id="var-cursor-.3Elazyseq"><h3><a href="#var-cursor-.3Elazyseq">cursor-&gt;lazyseq</a></h3><div class="usage"><code>(cursor-&gt;lazyseq cursor)</code><code>(cursor-&gt;lazyseq cursor opts)</code></div><div class="doc"><div class="markdown"><p>Transform a cursor in a lazyseq.</p><p>The returned lazyseq will return values until a cursor is closed or all values are fetched.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L164">view source</a></div></div><div class="public anchor" id="var-execute"><h3><a href="#var-execute">execute</a></h3><div class="usage"><code>(execute conn q)</code><code>(execute conn q opts)</code></div><div class="doc"><div class="markdown"><p>Execute a query and return a number of rows affected.</p>
<pre><code>(with-open [conn (jdbc/connection dbspec)]
  (jdbc/execute conn &quot;create table foo (id integer);&quot;))
</code></pre><p>This function also accepts sqlvec format.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L112">view source</a></div></div><div class="public anchor" id="var-fetch"><h3><a href="#var-fetch">fetch</a></h3><div class="usage"><code>(fetch conn q)</code><code>(fetch conn q opts)</code></div><div class="doc"><div class="markdown"><p>Fetch eagerly results executing a query.</p><p>This function returns a vector of records (default) or rows (depending on specified opts). Resources are relased inmediatelly without specific explicit action for it.</p><p>It accepts a sqlvec, plain sql or prepared statement as query parameter.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L124">view source</a></div></div><div class="public anchor" id="var-fetch-lazy"><h3><a href="#var-fetch-lazy">fetch-lazy</a></h3><div class="usage"><code>(fetch-lazy conn q)</code><code>(fetch-lazy conn q opts)</code></div><div class="doc"><div class="markdown"><p>Fetch lazily results executing a query.</p>
<pre><code>(with-open [cursor (jdbc/fetch-lazy conn sql)]
  (doseq [item (jdbc/cursor-&gt;lazyseq cursor)]
    (do-something-with item)))
</code></pre><p>This function returns a cursor instead of result. You should explicitly close the cursor at the end of iteration for release resources.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L144">view source</a></div></div><div class="public anchor" id="var-fetch-one"><h3><a href="#var-fetch-one">fetch-one</a></h3><div class="usage"><code>(fetch-one conn q)</code><code>(fetch-one conn q opts)</code></div><div class="doc"><div class="markdown"><p>Fetch eagerly one restult executing a query.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L138">view source</a></div></div><div class="public anchor" id="var-lazy-query"><h3><a href="#var-lazy-query">lazy-query</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Deprecated alias for backward compatibility.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L160">view source</a></div></div><div class="public anchor" id="var-prepared-statement"><h3><a href="#var-prepared-statement">prepared-statement</a></h3><div class="usage"><code>(prepared-statement conn sqlvec)</code><code>(prepared-statement conn sqlvec options)</code></div><div class="doc"><div class="markdown"><p>Given a string or parametrized sql in sqlvec format return an instance of prepared statement.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L104">view source</a></div></div><div class="public anchor" id="var-prepared-statement.3F"><h3><a href="#var-prepared-statement.3F">prepared-statement?</a></h3><div class="usage"><code>(prepared-statement? obj)</code></div><div class="doc"><div class="markdown"><p>Check if specified object is prepared statement.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L99">view source</a></div></div><div class="public anchor" id="var-set-rollback.21"><h3><a href="#var-set-rollback.21">set-rollback!</a></h3><div class="usage"><code>(set-rollback! conn)</code></div><div class="doc"><div class="markdown"><p>Mark a current connection for rollback.</p><p>It ensures that on the end of the current transaction instead of commit changes, rollback them.</p><p>This function should be used inside of a transaction block, otherwise this function does nothing.</p>
<pre><code>(jdbc/atomic conn
  (make-some-queries-without-changes conn)
  (jdbc/set-rollback! conn))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L236">view source</a></div></div></section></section></body></html>