<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>jdbc.core documentation</title></head><body><header><section class="title"><h1><a href="index.html">Clojure.jdbc Api Documentation</a></h1></section><small>Version: 0.5.1</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></div></li><li class="depth-2 branch"><a href="jdbc.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-2 branch current"><a href="jdbc.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jdbc.meta.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meta</span></div></a></li><li class="depth-2 branch"><a href="jdbc.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2"><a href="jdbc.resultset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>resultset</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">jdbc.core</h2><div class="doc"><div class="markdown"><p>Alternative implementation of jdbc wrapper for clojure.</p></div></div><div class="public anchor" id="var-atomic"><h3><a href="#var-atomic">atomic</a></h3><h4 class="type">macro</h4><div class="usage"><code>(atomic conn &amp; body)</code></div><div class="doc"><div class="markdown"><p>Creates a context that evaluates in transaction (or nested transaction). This is a more idiomatic way to execute some database operations in atomic way.</p>
<pre><code>(jdbc/atomic conn
  (jdbc/execute conn &quot;DROP TABLE foo;&quot;)
  (jdbc/execute conn &quot;DROP TABLE bar;&quot;))
</code></pre><p>Also, you can pass additional options to transaction:</p>
<pre><code>(jdbc/atomic conn {:read-only true}
  (jdbc/execute conn &quot;DROP TABLE foo;&quot;)
  (jdbc/execute conn &quot;DROP TABLE bar;&quot;))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L231">view source</a></div></div><div class="public anchor" id="var-atomic-apply"><h3><a href="#var-atomic-apply">atomic-apply</a></h3><div class="usage"><code>(atomic-apply conn func &amp; [{:keys [savepoints strategy], :or {savepoints true}, :as opts}])</code></div><div class="doc"><div class="markdown"><p>Wrap function in one transaction. This function accepts as a parameter a transaction strategy. If no one is specified, <code>DefaultTransactionStrategy</code> is used.</p><p>With <code>DefaultTransactionStrategy</code>, if current connection is already in transaction, it uses truly nested transactions for properly handle it. The availability of this feature depends on database support for it.</p>
<pre><code>(with-open [conn (jdbc/connection)]
  (atomic-apply conn (fn [conn] (execute! conn &#39;DROP TABLE foo;&#39;))))
</code></pre><p>For more idiomatic code, you should use <code>atomic</code> macro.</p><p>Depending on transaction strategy you are using, this function can accept additional parameters. The default transaction strategy exposes two additional parameters:</p>
<ul>
  <li><code>:isolation-level</code> - set isolation level for this transaction</li>
  <li><code>:read-only</code> - set current transaction to read only</li>
</ul></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L193">view source</a></div></div><div class="public anchor" id="var-connection"><h3><a href="#var-connection">connection</a></h3><div class="usage"><code>(connection dbspec)</code><code>(connection dbspec options)</code></div><div class="doc"><div class="markdown"><p>Creates a connection to a database. As parameter accepts:</p>
<ul>
  <li>dbspec map containing connection parameters</li>
  <li>dbspec map containing a datasource (deprecated)</li>
  <li>URI or string (interpreted as uri)</li>
  <li>DataSource instance</li>
</ul><p>The dbspec map has this possible variants:</p><p>Classic approach:</p>
<ul>
  <li><code>:subprotocol</code> -&gt; (required) string that represents a vendor name (ex: postgresql)</li>
  <li><code>:subname</code> -&gt; (required) string that represents a database name (ex: test)  (many others options that are pased directly as driver parameters)</li>
</ul><p>Pretty format:</p>
<ul>
  <li><code>:vendor</code> -&gt; (required) string that represents a vendor name (ex: postgresql)</li>
  <li><code>:name</code> -&gt; (required) string that represents a database name (ex: test)</li>
  <li><code>:host</code> -&gt; (optional) string that represents a database hostname (default: 127.0.0.1)</li>
  <li><code>:port</code> -&gt; (optional) long number that represents a database port (default: driver default)  (many others options that are pased directly as driver parameters)</li>
</ul><p>URI or String format: <code>vendor://user:password@host:post/dbname?param1=value</code></p><p>Additional options:</p>
<ul>
  <li><code>:schema</code> -&gt; string that represents a schema name (default: nil)</li>
  <li><code>:read-only</code> -&gt; boolean for mark entire connection read only.</li>
  <li><code>:isolation-level</code> -&gt; keyword that represents a isolation level (<code>:none</code>, <code>:read-committed</code>,  <code>:read-uncommitted</code>, <code>:repeatable-read</code>, <code>:serializable</code>)</li>
</ul><p>Opions can be passed as part of dbspec map, or as optional second argument. For more details, see documentation.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L54">view source</a></div></div><div class="public anchor" id="var-cursor-.3Elazyseq"><h3><a href="#var-cursor-.3Elazyseq">cursor-&gt;lazyseq</a></h3><div class="usage"><code>(cursor-&gt;lazyseq cursor)</code><code>(cursor-&gt;lazyseq cursor opts)</code></div><div class="doc"><div class="markdown"><p>Transform a cursor in a lazyseq.</p><p>The returned lazyseq will return values until a cursor is closed or all values are fetched.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L181">view source</a></div></div><div class="public anchor" id="var-execute"><h3><a href="#var-execute">execute</a></h3><div class="usage"><code>(execute conn q)</code><code>(execute conn q opts)</code></div><div class="doc"><div class="markdown"><p>Execute a query and return a number of rows affected.</p>
<pre><code>(with-open [conn (jdbc/connection dbspec)]
  (jdbc/execute conn &quot;create table foo (id integer);&quot;))
</code></pre><p>This function also accepts sqlvec format.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L129">view source</a></div></div><div class="public anchor" id="var-execute.21"><h3><a href="#var-execute.21">execute!</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(execute! conn &amp; commands)</code></div><div class="doc"><div class="markdown"><p>Run arbitrary number of raw sql commands such as: CREATE TABLE, DROP TABLE, etc&hellip; If your want transactions, you can wrap this call in transaction using <code>with-transaction</code> context block macro that is available in <code>jdbc.transaction</code> namespace.</p><p>Warning: not all database servers support ddl in transactions.</p><p>Examples:</p>
<pre><code>;; Without transactions
(with-open [conn (connection dbspec)]
  (execute! conn &quot;CREATE TABLE foo (id serial, name text);&quot;))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L52">view source</a></div></div><div class="public anchor" id="var-execute-prepared.21"><h3><a href="#var-execute-prepared.21">execute-prepared!</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><div class="doc"><div class="markdown"><p>Given a active connection and sql (or prepared statement), executes a query in a database. This differs from <code>execute!</code> function with that this function allows pass parameters to query in a more safe way and permit pass group of parrams enabling bulk operations.</p><p>After connection, sql/prepared statement and any number of group of params you can pass options map (same as on <code>make-prepared-statement</code> function).</p><p>Note: Some options are incompatible with self defined prepared statement.</p><p>Example:</p>
<pre><code>(with-connection dbspec conn
  (let [sql &quot;UPDATE TABLE foo SET x = ? WHERE y = ?;&quot;]
    (execute-prepared! conn sql [1 2] [2 3] [3 4])))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L88">view source</a></div></div><div class="public anchor" id="var-execute-statement.21"><h3><a href="#var-execute-statement.21">execute-statement!</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(execute-statement! conn stmt param-groups)</code></div><div class="doc"><div class="markdown"><p>Given a connection statement and paramgroups (can be empty) execute the prepared statement and return results from it.</p><p>This is a low level interface and should be used with precaution. This function is used internally for execue raw sql such as CREATE/DROP table.</p><p>Status: Alpha - Implementation and name of this method can change on next versions.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L30">view source</a></div></div><div class="public anchor" id="var-fetch"><h3><a href="#var-fetch">fetch</a></h3><div class="usage"><code>(fetch conn q)</code><code>(fetch conn q opts)</code></div><div class="doc"><div class="markdown"><p>Fetch eagerly results executing a query.</p><p>This function returns a vector of records (default) or rows (depending on specified opts). Resources are relased inmediatelly without specific explicit action for it.</p><p>It accepts a sqlvec, plain sql or prepared statement as query parameter.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L141">view source</a></div></div><div class="public anchor" id="var-fetch-lazy"><h3><a href="#var-fetch-lazy">fetch-lazy</a></h3><div class="usage"><code>(fetch-lazy conn q)</code><code>(fetch-lazy conn q opts)</code></div><div class="doc"><div class="markdown"><p>Fetch lazily results executing a query.</p>
<pre><code>(with-open [cursor (jdbc/fetch-lazy conn sql)]
  (doseq [item (jdbc/cursor-&gt;lazyseq cursor)]
    (do-something-with item)))
</code></pre><p>This function returns a cursor instead of result. You should explicitly close the cursor at the end of iteration for release resources.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L161">view source</a></div></div><div class="public anchor" id="var-fetch-one"><h3><a href="#var-fetch-one">fetch-one</a></h3><div class="usage"><code>(fetch-one conn q)</code><code>(fetch-one conn q opts)</code></div><div class="doc"><div class="markdown"><p>Fetch eagerly one restult executing a query.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L155">view source</a></div></div><div class="public anchor" id="var-get-returning-records"><h3><a href="#var-get-returning-records">get-returning-records</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(get-returning-records conn stmt)</code></div><div class="doc"><div class="markdown"><p>Given a executed prepared statement with expected returning values. Return a vector of records of returning values. Usually is a id of just inserted objects, but in other cases can be complete objects.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L73">view source</a></div></div><div class="public anchor" id="var-is-prepared-statement.3F"><h3><a href="#var-is-prepared-statement.3F">is-prepared-statement?</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(is-prepared-statement? obj)</code></div><div class="doc"><div class="markdown"><p>Check if specified object is prepared statement.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L83">view source</a></div></div><div class="public anchor" id="var-lazy-query"><h3><a href="#var-lazy-query">lazy-query</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Deprecated alias for backward compatibility.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L177">view source</a></div></div><div class="public anchor" id="var-prepared-statement"><h3><a href="#var-prepared-statement">prepared-statement</a></h3><div class="usage"><code>(prepared-statement conn sqlvec)</code><code>(prepared-statement conn sqlvec options)</code></div><div class="doc"><div class="markdown"><p>Given a string or parametrized sql in sqlvec format return an instance of prepared statement.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L121">view source</a></div></div><div class="public anchor" id="var-prepared-statement.3F"><h3><a href="#var-prepared-statement.3F">prepared-statement?</a></h3><div class="usage"><code>(prepared-statement? obj)</code></div><div class="doc"><div class="markdown"><p>Check if specified object is prepared statement.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L116">view source</a></div></div><div class="public anchor" id="var-query"><h3><a href="#var-query">query</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(query conn sqlvec)</code><code>(query conn sqlvec options)</code></div><div class="doc"><div class="markdown"><p>Perform a simple sql query and return a evaluated result as vector.</p><p><code>sqlvec</code> parameter can be: parametrized sql (vector format), plain sql (simple sql string) or prepared statement instance.</p><p>Example using parametrized sql:</p>
<pre><code>(doseq [row (query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
  (println row))
</code></pre><p>Example using plain sql (without parameters):</p>
<pre><code>(doseq [row (query conn &quot;SELECT version();&quot;)]
  (println row))
</code></pre><p>Example using extern prepared statement:</p>
<pre><code>(let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
  (doseq [row (query conn stmt)]
    (println row)))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L143">view source</a></div></div><div class="public anchor" id="var-query-first"><h3><a href="#var-query-first">query-first</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Perform a simple sql query and return the first result. It accepts the same arguments as the <code>query</code> function.</p></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core_deprecated.clj#L172">view source</a></div></div><div class="public anchor" id="var-set-rollback.21"><h3><a href="#var-set-rollback.21">set-rollback!</a></h3><div class="usage"><code>(set-rollback! conn)</code></div><div class="doc"><div class="markdown"><p>Mark a current connection for rollback.</p><p>It ensures that on the end of the current transaction instead of commit changes, rollback them.</p><p>This function should be used inside of a transaction block, otherwise this function does nothing.</p>
<pre><code>(jdbc/atomic conn
  (make-some-queries-without-changes conn)
  (jdbc/set-rollback! conn))
</code></pre></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L253">view source</a></div></div></section></section></body></html>